<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayer Times Tool</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.lordicon.com/lordicon.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <style>
        :root {
            --gradient-start: #6366f1;
            --gradient-end: #8b5cf6;
            --accent-color: #6366f1;
            --accent-dark: #4f46e5;
            --card-bg: rgba(255, 255, 255, 0.9);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            font-family: 'Tajawal', sans-serif;
            overflow-x: hidden;
        }

        .custom-gradient {
            background: linear-gradient(135deg, var(--gradient-start), var(--gradient-end));
        }

        .prayer-time-card {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: var(--card-bg);
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .prayer-time-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--gradient-start), var(--gradient-end));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .prayer-time-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.25);
        }

        .prayer-time-card:hover::before {
            opacity: 1;
        }

        .prayer-time-card.active {
            border: 2px solid var(--accent-color);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }

        .prayer-time-card.active::before {
            opacity: 1;
            width: 6px;
        }

        .arabic {
            font-family: 'Tajawal', sans-serif;
            font-weight: 500;
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) rgba(240, 240, 240, 0.7);
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(240, 240, 240, 0.7);
            border-radius: 10px;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 10px;
        }

        .countdown {
            font-variant-numeric: tabular-nums;
        }

        .icon-float {
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 5px 15px rgba(99, 102, 241, 0.3));
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .nav-shine {
            position: relative;
            overflow: hidden;
        }

        .nav-shine::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(30deg);
            animation: shine 6s infinite linear;
        }

        @keyframes shine {
            from { transform: translateX(-100%) rotate(30deg); }
            to { transform: translateX(100%) rotate(30deg); }
        }

        @media (prefers-reduced-motion) {
            .icon-float, .nav-shine::after {
                animation: none;
            }
        }
    </style>
</head>
<body class="min-h-screen pb-8 scrollbar">
    <!-- Navigation -->
    <nav class="custom-gradient shadow-lg text-white sticky top-0 z-50 nav-shine">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <div class="flex items-center space-x-3 animate__animated animate__fadeInLeft">
                    <lord-icon
                        src="https://cdn.lordicon.com/xnwbsupk.json"
                        trigger="loop"
                        colors="primary:#ffffff"
                        style="width:40px;height:40px">
                    </lord-icon>
                    <h1 class="text-2xl font-bold">Prayer Times | أوقات الصلاة</h1>
                </div>
                <div class="flex items-center space-x-4 animate__animated animate__fadeInRight">
                    <div id="current-date" class="text-white font-medium hidden md:block"></div>
                    <div id="location-display" class="text-white font-semibold bg-indigo-700 px-3 py-1 rounded-full text-sm flex items-center">
                        <i class="fas fa-map-marker-alt mr-1"></i>
                        <span>Loading...</span>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-6xl mx-auto px-4 py-8">
        <!-- Next Prayer Counter -->
        <div class="bg-white bg-opacity-90 rounded-2xl shadow-xl p-6 mb-8 transform transition-all duration-500 animate__animated animate__fadeInUp backdrop-filter backdrop-blur-md border border-indigo-100">
            <div class="flex flex-col md:flex-row items-center justify-between">
                <div class="flex items-center mb-4 md:mb-0">
                    <lord-icon
                        src="https://cdn.lordicon.com/osvvqecf.json"
                        trigger="loop"
                        colors="primary:#6366f1,secondary:#8b5cf6"
                        style="width:64px;height:64px" class="icon-float">
                    </lord-icon>
                    <div class="ml-4">
                        <h2 class="text-2xl font-bold text-indigo-600">Next Prayer | الصلاة القادمة</h2>
                        <p id="next-prayer-name" class="text-lg text-gray-600 flex flex-col md:flex-row">
                            <span class="mr-2">Loading...</span>
                            <span class="arabic mr-2">جاري التحميل...</span>
                        </p>
                    </div>
                </div>
                <div class="text-center">
                    <div id="time-remaining" class="countdown text-4xl font-bold text-indigo-600">--:--:--</div>
                    <p class="text-gray-500 text-sm">Time Remaining | الوقت المتبقي</p>
                </div>
            </div>
        </div>

        <!-- Prayer Times Grid -->
        <div id="prayer-times" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
            <!-- Prayer cards will be inserted here by JavaScript -->
        </div>
    </main>

    <!-- Footer -->
    <footer class="mt-12 pt-8 pb-6 text-center text-gray-500">
        <div class="flex justify-center mb-4">
            <lord-icon
                src="https://cdn.lordicon.com/dnmvmpfk.json"
                trigger="hover"
                colors="primary:#6366f1"
                style="width:48px;height:48px">
            </lord-icon>
        </div>
        <p>Prayer Times Tool &copy; 2025 | Accurate Islamic Prayer Times</p>
    </footer>

    <script>
      // Adhan.js-inspired prayer times calculation
// Accurate prayer times calculation with proper location handling and error management

// Prayer names in Arabic
const prayerNamesArabic = {
    Fajr: 'الفجر',
    Sunrise: 'الشروق',
    Dhuhr: 'الظهر',
    Asr: 'العصر',
    Maghrib: 'المغرب',
    Isha: 'العشاء'
};

// Prayer descriptions in Arabic
const prayerDescArabic = {
    Fajr: 'صلاة الفجر',
    Sunrise: 'شروق الشمس',
    Dhuhr: 'صلاة الظهر',
    Asr: 'صلاة العصر',
    Maghrib: 'صلاة المغرب',
    Isha: 'صلاة العشاء'
};

// Lord icon sources for each prayer time
const prayerIcons = {
    Fajr: 'https://cdn.lordicon.com/spgozyor.json',
    Sunrise: 'https://cdn.lordicon.com/qtedxnsm.json',
    Dhuhr: 'https://cdn.lordicon.com/oaflahpk.json',
    Asr: 'https://cdn.lordicon.com/uqpazftn.json',
    Maghrib: 'https://cdn.lordicon.com/wxnxiano.json',
    Isha: 'https://cdn.lordicon.com/udwhdpod.json'
};

// Color schemes for each prayer
const prayerColors = {
    Fajr: ['#6366f1', '#9333ea'],
    Sunrise: ['#f59e0b', '#d97706'],
    Dhuhr: ['#3b82f6', '#1d4ed8'],
    Asr: ['#10b981', '#065f46'],
    Maghrib: ['#ef4444', '#b91c1c'],
    Isha: ['#6366f1', '#4338ca']
};

// ======================== ACCURATE CALCULATION FUNCTIONS ======================== //

// Main calculation constants
const METHODS = {
    MWL: { fajrAngle: 18, ishaAngle: 17, name: 'Muslim World League' },
    ISNA: { fajrAngle: 15, ishaAngle: 15, name: 'Islamic Society of North America' },
    EGYPT: { fajrAngle: 19.5, ishaAngle: 17.5, name: 'Egyptian General Authority of Survey' },
    MAKKAH: { fajrAngle: 18.5, ishaIsMinutes: true, ishaValue: 90, name: 'Umm al-Qura University, Makkah' },
    KARACHI: { fajrAngle: 18, ishaAngle: 18, name: 'University of Islamic Sciences, Karachi' },
    TEHRAN: { fajrAngle: 17.7, ishaAngle: 14, name: 'Institute of Geophysics, Tehran University' },
    GULF: { fajrAngle: 19.5, ishaIsMinutes: true, ishaValue: 90, name: 'Gulf Region' }
};

// Default calculation method
let CALCULATION_METHOD = METHODS.MWL;

// Default Asr calculation method - 1 for Shafi'i, 2 for Hanafi
let ASR_SHADOW_FACTOR = 1;

// Global variable to store the countdown timer
let countdownTimer = null;

// Utility functions for degree/radian conversion
function toRadians(degrees) {
    return degrees * (Math.PI / 180);
}

function toDegrees(radians) {
    return radians * (180 / Math.PI);
}

// Calculate Julian date for a given date
function getJulianDate(date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    let adjustedYear = year;
    let adjustedMonth = month;
    
    if (month <= 2) {
        adjustedYear -= 1;
        adjustedMonth += 12;
    }
    
    const A = Math.floor(adjustedYear / 100);
    const B = 2 - A + Math.floor(A / 4);
    
    return Math.floor(365.25 * (adjustedYear + 4716)) + 
           Math.floor(30.6001 * (adjustedMonth + 1)) + 
           day + B - 1524.5;
}

// Calculate sun declination for a given Julian date
function getSunDeclination(julianDate) {
    // Approximate solar declination from Julian date
    const D = julianDate - 2451545.0;
    const g = 357.529 + 0.98560028 * D; // Mean anomaly of the sun
    const q = 280.459 + 0.98564736 * D; // Mean longitude of the sun
    
    // Geocentric apparent ecliptic longitude of the sun
    const L = q + 1.915 * Math.sin(toRadians(g)) + 0.020 * Math.sin(toRadians(2 * g));
    
    // Earth's axial tilt
    const e = 23.439 - 0.00000036 * D;
    
    // Sun's declination
    return toDegrees(Math.asin(Math.sin(toRadians(e)) * Math.sin(toRadians(L))));
}

// Calculate equation of time
function getEquationOfTime(julianDate) {
    // Approximate equation of time in minutes from Julian date
    const D = julianDate - 2451545.0;
    const g = 357.529 + 0.98560028 * D; // Mean anomaly of the sun
    const q = 280.459 + 0.98564736 * D; // Mean longitude of the sun
    
    // Geocentric apparent ecliptic longitude of the sun
    const L = q + 1.915 * Math.sin(toRadians(g)) + 0.020 * Math.sin(toRadians(2 * g));
    
    // Earth's axial tilt
    const e = 23.439 - 0.00000036 * D;
    
    // Right ascension
    let RA = toDegrees(Math.atan2(
        Math.cos(toRadians(e)) * Math.sin(toRadians(L)), 
        Math.cos(toRadians(L))
    ));
    
    // Adjust RA to be in the same quadrant as L
    const Lquadrant = Math.floor(L / 90) * 90;
    const RAquadrant = Math.floor(RA / 90) * 90;
    RA = RA + (Lquadrant - RAquadrant);
    
    // Convert to hours
    RA = RA / 15;
    
    // Equation of time: difference between apparent solar time and mean solar time
    return 4 * (q - RA); // in minutes
}

// Get timezone offset from browser in hours
function getTimeZoneOffset() {
    const now = new Date();
    return -(now.getTimezoneOffset() / 60);
}

// Calculate solar noon for a specific date and longitude
function getSolarNoon(date, longitude, timeZoneOffset) {
    const julianDate = getJulianDate(date);
    const equation = getEquationOfTime(julianDate);
    
    // Solar noon in hours (local standard time)
    return 12 + timeZoneOffset - (longitude / 15) - (equation / 60);
}

// Calculate prayer time for a specific angle (Fajr, Sunrise, Maghrib, Isha)
function calculateAngleBasedTime(date, latitude, longitude, angle, isAfterNoon) {
    const julianDate = getJulianDate(date);
    const declination = getSunDeclination(julianDate);
    const timeZone = getTimeZoneOffset();
    const midDay = getSolarNoon(date, longitude, timeZone);
    
    // Handle extreme latitudes
    const absLatitude = Math.abs(latitude);
    if (absLatitude >= 65) {
        // For extreme latitudes, use middle seasons method or nearest valid latitude
        if (absLatitude > 80) {
            // Too extreme, use approximation - fallback to Mecca
            return { status: "extreme_latitude", time: null }; 
        }
    }
    
    const term1 = Math.sin(toRadians(angle)) - 
                 Math.sin(toRadians(latitude)) * Math.sin(toRadians(declination));
    const term2 = Math.cos(toRadians(latitude)) * Math.cos(toRadians(declination));
    
    const cosTime = term1 / term2;
    
    // Check if the sun never reaches the angle
    if (cosTime > 1) {
        return { status: "never_above", time: null }; // Sun never rises above this angle
    } else if (cosTime < -1) {
        return { status: "never_below", time: null }; // Sun never goes below this angle
    }
    
    const timeAngle = toDegrees(Math.acos(cosTime));
    const timeHours = timeAngle / 15;
    
    // Apply the time adjustment based on whether it's before or after noon
    const adjustedTimeHours = isAfterNoon ? midDay + timeHours : midDay - timeHours;
    
    return { 
        status: "valid", 
        time: createTimeForHour(date, adjustedTimeHours)
    };
}

// Calculate Asr time based on shadow length factor
function calculateAsrTime(date, latitude, longitude, shadowFactor) {
    const julianDate = getJulianDate(date);
    const declination = getSunDeclination(julianDate);
    const timeZone = getTimeZoneOffset();
    const midDay = getSolarNoon(date, longitude, timeZone);
    
    // Shadow angle calculation for Asr
    const zenithDistance = Math.abs(latitude - declination);
    const asrAngle = toDegrees(Math.atan(1 / (shadowFactor + Math.tan(toRadians(zenithDistance)))));
    
    const term1 = Math.sin(toRadians(90 - asrAngle)) - 
                 Math.sin(toRadians(latitude)) * Math.sin(toRadians(declination));
    const term2 = Math.cos(toRadians(latitude)) * Math.cos(toRadians(declination));
    
    const cosTime = term1 / term2;
    
    // Make sure the result is valid
    if (cosTime > 1 || cosTime < -1) {
        return { status: "invalid", time: null };
    }
    
    const timeAngle = toDegrees(Math.acos(cosTime));
    const timeHours = timeAngle / 15;
    
    // Asr is always after noon
    return { 
        status: "valid", 
        time: createTimeForHour(date, midDay + timeHours)
    };
}

// Create a date object for a specific hour
function createTimeForHour(date, hours) {
    const result = new Date(date);
    const wholeHours = Math.floor(hours);
    const minutes = Math.floor((hours - wholeHours) * 60);
    const seconds = Math.floor(((hours - wholeHours) * 60 - minutes) * 60);
    
    result.setHours(wholeHours, minutes, seconds, 0);
    return result;
}

// Calculate all prayer times for a specific date, latitude and longitude
function calculatePrayerTimes(latitude, longitude, date) {
    // Prepare result object
    const result = {
        Fajr: null,
        Sunrise: null,
        Dhuhr: null,
        Asr: null,
        Maghrib: null,
        Isha: null
    };
    
    // Get timezone offset
    const timeZoneOffset = getTimeZoneOffset();
    
    // Set date to midnight for consistent calculations
    const calculationDate = new Date(date);
    calculationDate.setHours(0, 0, 0, 0);
    
    // Calculate Fajr
    const fajrCalc = calculateAngleBasedTime(
        calculationDate, 
        latitude, 
        longitude, 
        -CALCULATION_METHOD.fajrAngle, 
        false
    );
    
    if (fajrCalc.status === "valid") {
        result.Fajr = fajrCalc.time;
    } else {
        // In extreme latitudes, handle special cases
        result.Fajr = "-----";
    }
    
    // Calculate Sunrise (approx -0.833 degrees due to refraction and solar radius)
    const sunriseCalc = calculateAngleBasedTime(
        calculationDate, 
        latitude, 
        longitude, 
        -0.833, 
        false
    );
    
    if (sunriseCalc.status === "valid") {
        result.Sunrise = sunriseCalc.time;
    } else {
        result.Sunrise = "-----";
    }
    
    // Calculate Dhuhr (solar noon)
    const midDay = getSolarNoon(calculationDate, longitude, timeZoneOffset);
    result.Dhuhr = createTimeForHour(calculationDate, midDay);
    
    // Calculate Asr
    const asrCalc = calculateAsrTime(
        calculationDate, 
        latitude, 
        longitude, 
        ASR_SHADOW_FACTOR
    );
    
    if (asrCalc.status === "valid") {
        result.Asr = asrCalc.time;
    } else {
        result.Asr = "-----";
    }
    
    // Calculate Maghrib (approx +0.833 degrees due to refraction and solar radius)
    const maghribCalc = calculateAngleBasedTime(
        calculationDate, 
        latitude, 
        longitude, 
        0.833, 
        true
    );
    
    if (maghribCalc.status === "valid") {
        result.Maghrib = maghribCalc.time;
    } else {
        result.Maghrib = "-----";
    }
    
    // Calculate Isha
    if (CALCULATION_METHOD.ishaIsMinutes) {
        // If Isha is calculated based on minutes after Maghrib
        if (maghribCalc.status === "valid") {
            const ishaTime = new Date(maghribCalc.time);
            ishaTime.setMinutes(ishaTime.getMinutes() + CALCULATION_METHOD.ishaValue);
            result.Isha = ishaTime;
        } else {
            result.Isha = "-----";
        }
    } else {
        // If Isha is calculated based on sun angle
        const ishaCalc = calculateAngleBasedTime(
            calculationDate, 
            latitude, 
            longitude, 
            -CALCULATION_METHOD.ishaAngle, 
            true
        );
        
        if (ishaCalc.status === "valid") {
            result.Isha = ishaCalc.time;
        } else {
            result.Isha = "-----";
        }
    }
    
    // Format all valid times to strings
    Object.keys(result).forEach(prayer => {
        if (result[prayer] !== "-----" && result[prayer] instanceof Date) {
            result[prayer] = formatTime(result[prayer]);
        }
    });
    
    return result;
}

// ======================== FORMATTING FUNCTIONS ======================== //

// Format a Date object to time string (12-hour format)
function formatTime(date) {
    if (!(date instanceof Date)) return "-----";
    return date.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: true 
    });
}

// Format time string to Arabic numerals
function formatTimeArabic(timeStr) {
    if (timeStr === "-----") return "-----";
    
    // Convert to 24-hour format first
    const [time, period] = timeStr.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    
    // Format with Arabic numerals
    const arabicDigits = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
    const hoursStr = hours.toString().padStart(2, '0').split('').map(d => arabicDigits[parseInt(d)]).join('');
    const minutesStr = minutes.toString().padStart(2, '0').split('').map(d => arabicDigits[parseInt(d)]).join('');
    
    return `${hoursStr}:${minutesStr}`;
}

// Convert time string to Date object for comparison
function convertTimeStringToDate(timeStr) {
    if (timeStr === "-----") return null;
    
    const today = new Date();
    const [time, period] = timeStr.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    
    const result = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hours, minutes);
    return result;
}

// ======================== UI UPDATE FUNCTIONS ======================== //

// Safely get DOM element with fallback
function safeGetElement(id, fallback = null) {
    const element = document.getElementById(id);
    if (!element && fallback) {
        console.warn(`Element with ID '${id}' not found, creating it`);
        const newElement = document.createElement(fallback);
        newElement.id = id;
        document.body.appendChild(newElement);
        return newElement;
    }
    return element;
}

// Display the prayer times in the UI
function displayPrayerTimes(times) {
    const container = safeGetElement('prayer-times', 'div');
    if (!container) {
        console.error('Prayer times container not found and could not be created');
        return;
    }
    
    container.innerHTML = '';

    const prayers = {
        Fajr: ['Dawn Prayer', 'fa-sun'],
        Sunrise: ['Sunrise', 'fa-sun'],
        Dhuhr: ['Noon Prayer', 'fa-sun'],
        Asr: ['Afternoon Prayer', 'fa-cloud-sun'],
        Maghrib: ['Sunset Prayer', 'fa-moon'],
        Isha: ['Night Prayer', 'fa-star']
    };

    const currentTime = new Date();
    let nextPrayer = null;
    let nextPrayerTime = null;

    // First determine the next prayer
    Object.entries(prayers).forEach(([prayer, [label, icon]]) => {
        if (times[prayer] === "-----") return;
        
        const prayerDate = convertTimeStringToDate(times[prayer]);
        
        if (prayerDate && prayerDate > currentTime && (!nextPrayerTime || prayerDate < nextPrayerTime)) {
            nextPrayer = prayer;
            nextPrayerTime = prayerDate;
        }
    });

    // Handle case where all prayers have passed for the day
    if (!nextPrayer) {
        // Set Fajr of the next day as the next prayer
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        // Recalculate for tomorrow
        const tomorrowTimes = calculatePrayerTimes(
            currentPosition.latitude, 
            currentPosition.longitude, 
            tomorrow
        );
        
        nextPrayer = 'Fajr';
        nextPrayerTime = convertTimeStringToDate(tomorrowTimes.Fajr);
        
        // If still no valid time (e.g., extreme latitude), show placeholder
        if (!nextPrayerTime) {
            const nextPrayerNameElement = safeGetElement('next-prayer-name', 'div');
            if (nextPrayerNameElement) {
                nextPrayerNameElement.innerHTML = `
                    <span class="mr-2">No upcoming prayers available</span>
                    <span class="arabic mr-2">لا توجد صلوات قادمة متاحة</span>
                `;
            }
            
            const timeRemainingElement = safeGetElement('time-remaining', 'div');
            if (timeRemainingElement) {
                timeRemainingElement.textContent = "--:--:--";
            }
        }
    }

    // Now create cards
    Object.entries(prayers).forEach(([prayer, [label, icon]], index) => {
        const isActive = prayer === nextPrayer;
        const [primary, secondary] = prayerColors[prayer] || ['#6366f1', '#8b5cf6'];
        
        const card = document.createElement('div');
        card.className = `prayer-time-card rounded-xl shadow-lg p-6 animate__animated animate__fadeIn animate__delay-${index % 5}s ${isActive ? 'active' : ''}`;
        if (isActive) {
            card.style.background = `linear-gradient(145deg, ${primary}15, ${secondary}15)`;
        }
        
        card.innerHTML = `
            <div class="flex items-center justify-between mb-3">
                <div>
                    <h3 class="text-xl font-bold ${isActive ? 'text-indigo-700' : 'text-indigo-600'}">${label}</h3>
                    <p class="text-gray-600">${prayer} | ${prayerNamesArabic[prayer]}</p>
                </div>
                <lord-icon
                    src="${prayerIcons[prayer]}"
                    trigger="hover"
                    colors="primary:${primary},secondary:${secondary}"
                    style="width:48px;height:48px">
                </lord-icon>
            </div>
            <div class="flex items-center justify-between mt-4">
                <div class="flex flex-col">
                    <span class="text-sm text-gray-500">English</span>
                    <span class="text-lg font-semibold ${isActive ? 'text-indigo-700' : 'text-gray-700'}">${times[prayer]}</span>
                </div>
                <div class="flex flex-col items-end">
                    <span class="text-sm text-gray-500">عربي</span>
                    <span dir="rtl" class="text-lg font-semibold arabic ${isActive ? 'text-indigo-700' : 'text-gray-700'}">${formatTimeArabic(times[prayer])}</span>
                </div>
            </div>
            ${isActive ? '<div class="mt-2 text-xs text-indigo-600 font-medium">Next Prayer</div>' : ''}
        `;
        container.appendChild(card);
    });

    // Update next prayer information
    if (nextPrayer && nextPrayerTime) {
        const nextPrayerNameElement = safeGetElement('next-prayer-name', 'div');
        if (nextPrayerNameElement) {
            nextPrayerNameElement.innerHTML = `
                <span class="mr-2">${prayers[nextPrayer][0]} (${nextPrayer})</span>
                <span class="arabic mr-2">${prayerDescArabic[nextPrayer]} (${prayerNamesArabic[nextPrayer]})</span>
            `;
        }
        updateCountdown(nextPrayerTime);
    }
}

// Update the countdown timer
function updateCountdown(targetTime) {
    if (!targetTime) return;
    
    const timeRemainingElement = safeGetElement('time-remaining', 'div');
    if (!timeRemainingElement) {
        console.error('Time remaining element not found and could not be created');
        return;
    }
    
    const updateTimer = () => {
        const now = new Date();
        const diff = targetTime - now;
        
        if (diff <= 0) {
            timeRemainingElement.textContent = "00:00:00";
            // Refresh the page calculations when time is up
            setTimeout(() => {
                refreshPrayerTimes();
            }, 1000);
            return;
        }
        
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        
        timeRemainingElement.textContent = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update every second
        countdownTimer = setTimeout(updateTimer, 1000);
    };
    
    // Clear any existing timer before starting a new one
    if (countdownTimer) {
        clearTimeout(countdownTimer);
    }
    
    updateTimer();
}

// Update the current date
function updateCurrentDate() {
    const currentDateElement = safeGetElement('current-date', 'div');
    if (!currentDateElement) return;
    
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const today = new Date();
    
    const gregorianDate = today.toLocaleDateString('en-US', options);
    currentDateElement.textContent = gregorianDate;
}

// ======================== LOCATION HANDLING ======================== //

// Global variable to store current position
let currentPosition = {
    latitude: null,
    longitude: null
};

// Function to handle location retrieval and updates
async function getCurrentLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            return reject(new Error('Geolocation is not supported by your browser'));
        }
        
        // Show loading state
        updateLoadingState(true, 'Retrieving your location...');
        
        navigator.geolocation.getCurrentPosition(
            // Success callback
            (position) => {
                const { latitude, longitude } = position.coords;
                currentPosition = { latitude, longitude };
                updateLoadingState(false);
                resolve(position.coords);
            },
            // Error callback
            (error) => {
                updateLoadingState(false);
                
                let errorMessage;
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = 'Location access was denied. Prayer times may not be accurate.';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = 'Location information is unavailable. Using default location.';
                        break;
                    case error.TIMEOUT:
                        errorMessage = 'Location request timed out. Using cached or default location.';
                        break;
                    default:
                        errorMessage = 'An unknown error occurred while retrieving location.';
                }
                
                reject(new Error(errorMessage));
            },
            // Options
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
            }
        );
    });
}

// Show/hide a loading indicator
function updateLoadingState(isLoading, message = 'Loading...') {
    const locationDisplay = safeGetElement('location-display', 'div');
    if (!locationDisplay) return;
    
    if (isLoading) {
        locationDisplay.innerHTML = `
            <div class="flex items-center">
                <div class="animate-spin mr-2">
                    <i class="fas fa-circle-notch"></i>
                </div>
                <span>${message}</span>
            </div>
        `;
    } else {
        // Reset to default state - will be updated later
        locationDisplay.innerHTML = `
            <i class="fas fa-map-marker-alt mr-1"></i>
            <span>Location pending...</span>
        `;
    }
}

// Fetch location name from coordinates
async function getLocationName(latitude, longitude) {
    try {
        updateLoadingState(true, 'Finding your city...');
        
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=10`,
            { 
                headers: { 
                    'Accept-Language': 'en',
                    'User-Agent': 'PrayerTimesApp/1.0'
                } 
            }
        );
        
        if (!response.ok) {
            throw new Error('Failed to fetch location data');
        }
        
        const data = await response.json();
        updateLoadingState(false);
        
        return data.address.city || 
               data.address.town || 
               data.address.village || 
               data.address.county ||
               data.address.state ||
               "Unknown Location";
    } catch (error) {
        updateLoadingState(false);
        console.error('Error fetching location name:', error);
        return "Unknown Location";
    }
}

// Update the location display
function updateLocationDisplay(locationName) {
    const locationDisplay = safeGetElement('location-display', 'div');
    if (!locationDisplay) return;
    
    locationDisplay.innerHTML = `
        <i class="fas fa-map-marker-alt mr-1"></i>
        <span>${locationName}</span>
    `;
}

// Continuation of the handleLocationError function
function handleLocationError(error) {
    console.error('Location error:', error);
    
    // Check if we have Swal (SweetAlert2) available
    if (typeof Swal !== 'undefined') {
        // Show error alert
        Swal.fire({
            title: 'Location Error',
            text: error.message || 'Unable to determine your location. Using default location.',
            icon: 'warning',
            confirmButtonText: 'Use Default Location',
            confirmButtonColor: '#6366f1',
            showCancelButton: true,
            cancelButtonText: 'Try Again',
            cancelButtonColor: '#ef4444'
        }).then((result) => {
            if (result.isConfirmed) {
                // Use default location (Mecca coordinates as fallback)
                currentPosition = { 
                    latitude: 21.4225, 
                    longitude: 39.8262 
                };
                updateLocationDisplay('Mecca (Default)');
                refreshPrayerTimes();
            } else {
                // Try again
                initialize();
            }
        });
    } else {
        // Fallback to simple alert if SweetAlert is not available
        const useDefault = window.confirm(
            `${error.message || 'Unable to determine your location.'} Would you like to use the default location (Mecca)?`
        );
        
        if (useDefault) {
            // Use default location (Mecca coordinates)
            currentPosition = { 
                latitude: 21.4225, 
                longitude: 39.8262 
            };
            updateLocationDisplay('Mecca (Default)');
            refreshPrayerTimes();
        } else {
            // Try again
            initialize();
        }
    }
}

// ======================== APPLICATION INITIALIZATION ======================== //

// Refresh prayer times with current settings
function refreshPrayerTimes() {
    if (!currentPosition.latitude || !currentPosition.longitude) {
        console.error('No location available');
        return;
    }
    
    const today = new Date();
    const times = calculatePrayerTimes(
        currentPosition.latitude, 
        currentPosition.longitude, 
        today
    );
    
    displayPrayerTimes(times);
    updateCurrentDate();
}

// Handle method selection change
function handleMethodChange(methodName) {
    if (METHODS[methodName]) {
        CALCULATION_METHOD = METHODS[methodName];
        
        // Update method display
        const methodDisplay = safeGetElement('calculation-method', 'div');
        if (methodDisplay) {
            methodDisplay.textContent = CALCULATION_METHOD.name;
        }
        
        refreshPrayerTimes();
    }
}

// Handle Asr calculation method change
function handleAsrMethodChange(asrMethod) {
    if (asrMethod === 'shafi' || asrMethod === '1') {
        ASR_SHADOW_FACTOR = 1;
    } else if (asrMethod === 'hanafi' || asrMethod === '2') {
        ASR_SHADOW_FACTOR = 2;
    }
    
    // Update Asr method display
    const asrMethodDisplay = safeGetElement('asr-method', 'div');
    if (asrMethodDisplay) {
        asrMethodDisplay.textContent = ASR_SHADOW_FACTOR === 1 ? 'Shafi\'i' : 'Hanafi';
    }
    
    refreshPrayerTimes();
}

// Setup event listeners for controls
function setupEventListeners() {
    // Method selection
    const methodSelect = safeGetElement('method-select', 'select');
    if (methodSelect) {
        // Populate method options if not already done
        if (methodSelect.options.length === 0) {
            Object.keys(METHODS).forEach(method => {
                const option = document.createElement('option');
                option.value = method;
                option.textContent = METHODS[method].name;
                methodSelect.appendChild(option);
            });
        }
        
        methodSelect.value = Object.keys(METHODS).find(
            key => METHODS[key].name === CALCULATION_METHOD.name
        ) || 'MWL';
        
        methodSelect.addEventListener('change', (e) => {
            handleMethodChange(e.target.value);
        });
    }
    
    // Asr method selection
    const asrMethodSelect = safeGetElement('asr-method-select', 'select');
    if (asrMethodSelect) {
        // Populate Asr method options if not already done
        if (asrMethodSelect.options.length === 0) {
            const options = [
                { value: '1', text: 'Shafi\'i (Standard)' },
                { value: '2', text: 'Hanafi' }
            ];
            
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.text;
                asrMethodSelect.appendChild(option);
            });
        }
        
        asrMethodSelect.value = ASR_SHADOW_FACTOR.toString();
        
        asrMethodSelect.addEventListener('change', (e) => {
            handleAsrMethodChange(e.target.value);
        });
    }
    
    // Refresh button
    const refreshButton = safeGetElement('refresh-button', 'button');
    if (refreshButton) {
        refreshButton.addEventListener('click', () => {
            initialize();
        });
    }
}

// Load settings from localStorage if available
function loadSettings() {
    try {
        // Load calculation method
        const savedMethod = localStorage.getItem('prayerCalculationMethod');
        if (savedMethod && METHODS[savedMethod]) {
            CALCULATION_METHOD = METHODS[savedMethod];
        }
        
        // Load Asr calculation method
        const savedAsrMethod = localStorage.getItem('asrShadowFactor');
        if (savedAsrMethod) {
            ASR_SHADOW_FACTOR = parseInt(savedAsrMethod) || 1;
        }
        
        // Update UI to reflect loaded settings
        const methodDisplay = safeGetElement('calculation-method', 'div');
        if (methodDisplay) {
            methodDisplay.textContent = CALCULATION_METHOD.name;
        }
        
        const asrMethodDisplay = safeGetElement('asr-method', 'div');
        if (asrMethodDisplay) {
            asrMethodDisplay.textContent = ASR_SHADOW_FACTOR === 1 ? 'Shafi\'i' : 'Hanafi';
        }
    } catch (error) {
        console.error('Error loading settings:', error);
    }
}

// Save settings to localStorage
function saveSettings() {
    try {
        // Find the key for the current calculation method
        const methodKey = Object.keys(METHODS).find(
            key => METHODS[key].name === CALCULATION_METHOD.name
        );
        
        // Save settings
        localStorage.setItem('prayerCalculationMethod', methodKey || 'MWL');
        localStorage.setItem('asrShadowFactor', ASR_SHADOW_FACTOR.toString());
    } catch (error) {
        console.error('Error saving settings:', error);
    }
}

// Initialize the application
async function initialize() {
    // Load saved settings
    loadSettings();
    
    // Setup UI event listeners
    setupEventListeners();
    
    try {
        // Get user location
        const coords = await getCurrentLocation();
        
        // Get location name
        const locationName = await getLocationName(coords.latitude, coords.longitude);
        updateLocationDisplay(locationName);
        
        // Calculate and display prayer times
        refreshPrayerTimes();
        
        // Save settings for next visit
        saveSettings();
    } catch (error) {
        handleLocationError(error);
    }
}

// Run initialization when DOM is loaded
document.addEventListener('DOMContentLoaded', initialize);

// Set up auto-refresh every minute to keep countdown accurate
setInterval(() => {
    const now = new Date();
    if (now.getSeconds() === 0) {
        refreshPrayerTimes();
    }
}, 1000);

// ======================== THEME AND LANGUAGE FUNCTIONS ======================== //

// Toggle dark mode
function toggleDarkMode() {
    const body = document.body;
    body.classList.toggle('dark-mode');
    
    // Save preference
    const isDarkMode = body.classList.contains('dark-mode');
    localStorage.setItem('darkMode', isDarkMode ? 'true' : 'false');
    
    // Update button icon
    const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
    if (darkModeButton) {
        darkModeButton.innerHTML = isDarkMode ? 
            '<i class="fas fa-sun"></i>' : 
            '<i class="fas fa-moon"></i>';
    }
}

// Toggle Arabic/English display priority
function toggleLanguage() {
    const container = document.getElementById('app-container');
    container.classList.toggle('arabic-primary');
    
    // Save preference
    const isArabicPrimary = container.classList.contains('arabic-primary');
    localStorage.setItem('arabicPrimary', isArabicPrimary ? 'true' : 'false');
    
    // Update button text
    const langButton = safeGetElement('language-toggle', 'button');
    if (langButton) {
        langButton.textContent = isArabicPrimary ? 'English' : 'العربية';
    }
}

// Load theme and language preferences
function loadPreferences() {
    // Dark mode preference
    const darkModeSetting = localStorage.getItem('darkMode');
    if (darkModeSetting === 'true') {
        document.body.classList.add('dark-mode');
        
        const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
        if (darkModeButton) {
            darkModeButton.innerHTML = '<i class="fas fa-sun"></i>';
        }
    }
    
    // Language preference
    const arabicPrimarySetting = localStorage.getItem('arabicPrimary');
    if (arabicPrimarySetting === 'true') {
        const container = document.getElementById('app-container');
        if (container) {
            container.classList.add('arabic-primary');
        }
        
        const langButton = safeGetElement('language-toggle', 'button');
        if (langButton) {
            langButton.textContent = 'English';
        }
    }
}

// Setup theme and language toggles
function setupPreferenceControls() {
    // Dark mode toggle
    const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
    if (darkModeButton) {
        darkModeButton.addEventListener('click', toggleDarkMode);
    }
    
    // Language toggle
    const langButton = safeGetElement('language-toggle', 'button');
    if (langButton) {
        langButton.addEventListener('click', toggleLanguage);
    }
    
    // Load saved preferences
    loadPreferences();
}

// Add preference controls setup to initialization
document.addEventListener('DOMContentLoaded', () => {
    setupPreferenceControls();
});

// ======================== EXPORT/SHARE FUNCTIONS ======================== //

// Generate shareable link with current settings
function generateShareableLink() {
    const methodKey = Object.keys(METHODS).find(
        key => METHODS[key].name === CALCULATION_METHOD.name
    ) || 'MWL';
    
    const params = new URLSearchParams({
        method: methodKey,
        asr: ASR_SHADOW_FACTOR.toString(),
        lat: currentPosition.latitude.toString(),
        lng: currentPosition.longitude.toString()
    });
    
    return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
}

// Copy shareable link to clipboard
function copyShareableLink() {
    const link = generateShareableLink();
    
    navigator.clipboard.writeText(link)
        .then(() => {
            // Show success message
            const shareButton = document.getElementById('share-button');
            if (shareButton) {
                const originalText = shareButton.textContent;
                shareButton.textContent = 'Copied!';
                
                setTimeout(() => {
                    shareButton.textContent = originalText;
                }, 2000);
            }
        })
        .catch(err => {
            console.error('Error copying to clipboard:', err);
            
            // Fallback for browsers without clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = link;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        });
}

// Export prayer times to calendar (iCal format)
function exportToCalendar() {
    if (!currentPosition.latitude || !currentPosition.longitude) {
        console.error('No location available for export');
        return;
    }
    
    // Get prayer times for the next 7 days
    const today = new Date();
    let icsContent = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Prayer Times App//EN',
        'CALSCALE:GREGORIAN',
        'METHOD:PUBLISH'
    ];
    
    // Generate events for the next 7 days
    for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() + i);
        
        const times = calculatePrayerTimes(
            currentPosition.latitude, 
            currentPosition.longitude, 
            date
        );
        
        // Add each prayer as an event
        Object.entries(times).forEach(([prayer, timeStr]) => {
            if (timeStr === "-----") return;
            
            const prayerTime = convertTimeStringToDate(timeStr);
            if (!prayerTime) return;
            
            // Set to the current date being processed
            prayerTime.setFullYear(date.getFullYear());
            prayerTime.setMonth(date.getMonth());
            prayerTime.setDate(date.getDate());
            
            // Format date for iCal
            const dtStart = prayerTime.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
            
            // Default duration of 30 minutes
            const dtEnd = new Date(prayerTime.getTime() + 30 * 60000).toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
            
            icsContent = icsContent.concat([
                'BEGIN:VEVENT',
                `DTSTART:${dtStart}`,
                `DTEND:${dtEnd}`,
                `SUMMARY:${prayer} Prayer`,
                `DESCRIPTION:${prayer} Prayer Time`,
                `LOCATION:${currentPosition.latitude}, ${currentPosition.longitude}`,
                'END:VEVENT'
            ]);
        });
    }
    
    // Close the calendar
    icsContent.push('END:VCALENDAR');
    
    // Create and download the file
    const blob = new Blob([icsContent.join('\r\n')], { type: 'text/calendar' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'prayer_times.ics';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Setup share and export buttons
function setupShareExportButtons() {
    // Share button
    const shareButton = safeGetElement('share-button', 'button');
    if (shareButton) {
        shareButton.addEventListener('click', copyShareableLink);
    }
    
    // Export button
    const exportButton = safeGetElement('export-button', 'button');
    if (exportButton) {
        exportButton.addEventListener('click', exportToCalendar);
    }
}

// Add share/export setup to initialization
document.addEventListener('DOMContentLoaded', () => {
    setupShareExportButtons();
});

// Parse URL parameters on load
function parseUrlParameters() {
    const params = new URLSearchParams(window.location.search);
    
    // Check for method parameter
    const methodParam = params.get('method');
    if (methodParam && METHODS[methodParam]) {
        CALCULATION_METHOD = METHODS[methodParam];
    }
    
    // Check for Asr method parameter
    const asrParam = params.get('asr');
    if (asrParam) {
        ASR_SHADOW_FACTOR = parseInt(asrParam) || 1;
    }
    
    // Check for location parameters
    const latParam = params.get('lat');
    const lngParam = params.get('lng');
    
    if (latParam && lngParam) {
        const lat = parseFloat(latParam);
        const lng = parseFloat(lngParam);
        
        if (!isNaN(lat) && !isNaN(lng)) {
            currentPosition = { latitude: lat, longitude: lng };
            
            // Update location name from coordinates
            getLocationName(lat, lng)
                .then(locationName => {
                    updateLocationDisplay(locationName);
                })
                .catch(() => {
                    updateLocationDisplay('Shared Location');
                });
                
            // Skip location detection if coordinates provided
            return true;
        }
    }
    
    return false;
}

// Check URL parameters at startup
document.addEventListener('DOMContentLoaded', () => {
    const hasLocationParams = parseUrlParameters();
    
    if (hasLocationParams) {
        // If we got location from URL, skip geolocation and calculate times
        refreshPrayerTimes();
    }
});
    </script>
</body>
</html>
