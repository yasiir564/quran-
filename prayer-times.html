<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayer Times Tool</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.lordicon.com/lordicon.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <style>
        :root {
            --gradient-start: #6366f1;
            --gradient-end: #8b5cf6;
            --accent-color: #6366f1;
            --accent-dark: #4f46e5;
            --card-bg: rgba(255, 255, 255, 0.9);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            font-family: 'Tajawal', sans-serif;
            overflow-x: hidden;
        }

        .custom-gradient {
            background: linear-gradient(135deg, var(--gradient-start), var(--gradient-end));
        }

        .prayer-time-card {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: var(--card-bg);
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .prayer-time-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--gradient-start), var(--gradient-end));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .prayer-time-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.25);
        }

        .prayer-time-card:hover::before {
            opacity: 1;
        }

        .prayer-time-card.active {
            border: 2px solid var(--accent-color);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }

        .prayer-time-card.active::before {
            opacity: 1;
            width: 6px;
        }

        .arabic {
            font-family: 'Tajawal', sans-serif;
            font-weight: 500;
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) rgba(240, 240, 240, 0.7);
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(240, 240, 240, 0.7);
            border-radius: 10px;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 10px;
        }

        .countdown {
            font-variant-numeric: tabular-nums;
        }

        .icon-float {
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 5px 15px rgba(99, 102, 241, 0.3));
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .nav-shine {
            position: relative;
            overflow: hidden;
        }

        .nav-shine::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(30deg);
            animation: shine 6s infinite linear;
        }

        @keyframes shine {
            from { transform: translateX(-100%) rotate(30deg); }
            to { transform: translateX(100%) rotate(30deg); }
        }

        @media (prefers-reduced-motion) {
            .icon-float, .nav-shine::after {
                animation: none;
            }
        }
        /* Dark Mode Toggle Animation */
.dark-mode-toggle {
  transition: transform 0.3s ease;
}

.dark-mode-toggle:hover {
  transform: rotate(30deg);
}

.dark-mode .dark-mode-toggle:hover {
  transform: rotate(-30deg);
}

/* Focus states for accessibility */
button:focus, select:focus {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

/* Add prayer color accents for Muslim World League */
.method-mwl .prayer-time-card:nth-child(1) {
  border-top: 3px solid #6366f1;
}

.method-mwl .prayer-time-card:nth-child(2) {
  border-top: 3px solid #f59e0b;
}

.method-mwl .prayer-time-card:nth-child(3) {
  border-top: 3px solid #3b82f6;
}

.method-mwl .prayer-time-card:nth-child(4) {
  border-top: 3px solid #10b981;
}

.method-mwl .prayer-time-card:nth-child(5) {
  border-top: 3px solid #ef4444;
}

.method-mwl .prayer-time-card:nth-child(6) {
  border-top: 3px solid #6366f1;
}
    </style>
</head>
<body class="min-h-screen pb-8 scrollbar">
    <!-- Navigation -->
    <nav class="custom-gradient shadow-lg text-white sticky top-0 z-50 nav-shine">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <div class="flex items-center space-x-3 animate__animated animate__fadeInLeft">
                    <lord-icon
                        src="https://cdn.lordicon.com/xnwbsupk.json"
                        trigger="loop"
                        colors="primary:#ffffff"
                        style="width:40px;height:40px">
                    </lord-icon>
                    <h1 class="text-2xl font-bold">Prayer Times | أوقات الصلاة</h1>
                </div>
                <div class="flex items-center space-x-4 animate__animated animate__fadeInRight">
                    <div id="current-date" class="text-white font-medium hidden md:block"></div>
                    <div id="location-display" class="text-white font-semibold bg-indigo-700 px-3 py-1 rounded-full text-sm flex items-center">
                        <i class="fas fa-map-marker-alt mr-1"></i>
                        <span>Loading...</span>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-6xl mx-auto px-4 py-8">
        <!-- Next Prayer Counter -->
        <div class="bg-white bg-opacity-90 rounded-2xl shadow-xl p-6 mb-8 transform transition-all duration-500 animate__animated animate__fadeInUp backdrop-filter backdrop-blur-md border border-indigo-100">
            <div class="flex flex-col md:flex-row items-center justify-between">
                <div class="flex items-center mb-4 md:mb-0">
                    <lord-icon
                        src="https://cdn.lordicon.com/osvvqecf.json"
                        trigger="loop"
                        colors="primary:#6366f1,secondary:#8b5cf6"
                        style="width:64px;height:64px" class="icon-float">
                    </lord-icon>
                    <div class="ml-4">
                        <h2 class="text-2xl font-bold text-indigo-600">Next Prayer | الصلاة القادمة</h2>
                        <p id="next-prayer-name" class="text-lg text-gray-600 flex flex-col md:flex-row">
                            <span class="mr-2">Loading...</span>
                            <span class="arabic mr-2">جاري التحميل...</span>
                        </p>
                    </div>
                </div>
                <div class="text-center">
                    <div id="time-remaining" class="countdown text-4xl font-bold text-indigo-600">--:--:--</div>
                    <p class="text-gray-500 text-sm">Time Remaining | الوقت المتبقي</p>
                </div>
            </div>
        </div>

        <!-- Prayer Times Grid -->
        <div id="prayer-times" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
            <!-- Prayer cards will be inserted here by JavaScript -->
        </div>
    </main>

    <!-- Footer -->
    <footer class="mt-12 pt-8 pb-6 text-center text-gray-500">
        <div class="flex justify-center mb-4">
            <lord-icon
                src="https://cdn.lordicon.com/dnmvmpfk.json"
                trigger="hover"
                colors="primary:#6366f1"
                style="width:48px;height:48px">
            </lord-icon>
        </div>
        <p>Prayer Times Tool &copy; 2025 | Accurate Islamic Prayer Times</p>
    </footer>

    <script>
     // Prayer times application using API instead of manual calculations
// This code fetches accurate prayer times from an API and provides a clean UI

// Prayer names in Arabic
const prayerNamesArabic = {
    Fajr: 'الفجر',
    Sunrise: 'الشروق',
    Dhuhr: 'الظهر',
    Asr: 'العصر',
    Maghrib: 'المغرب',
    Isha: 'العشاء'
};

// Prayer descriptions in Arabic
const prayerDescArabic = {
    Fajr: 'صلاة الفجر',
    Sunrise: 'شروق الشمس',
    Dhuhr: 'صلاة الظهر',
    Asr: 'صلاة العصر',
    Maghrib: 'صلاة المغرب',
    Isha: 'صلاة العشاء'
};

// Lord icon sources for each prayer time
const prayerIcons = {
    Fajr: 'https://cdn.lordicon.com/spgozyor.json',
    Sunrise: 'https://cdn.lordicon.com/qtedxnsm.json',
    Dhuhr: 'https://cdn.lordicon.com/oaflahpk.json',
    Asr: 'https://cdn.lordicon.com/uqpazftn.json',
    Maghrib: 'https://cdn.lordicon.com/wxnxiano.json',
    Isha: 'https://cdn.lordicon.com/udwhdpod.json'
};

// Color schemes for each prayer
const prayerColors = {
    Fajr: ['#6366f1', '#9333ea'],
    Sunrise: ['#f59e0b', '#d97706'],
    Dhuhr: ['#3b82f6', '#1d4ed8'],
    Asr: ['#10b981', '#065f46'],
    Maghrib: ['#ef4444', '#b91c1c'],
    Isha: ['#6366f1', '#4338ca']
};

// Available calculation methods
const METHODS = {
    MWL: { id: 3, name: 'Muslim World League' },
    ISNA: { id: 2, name: 'Islamic Society of North America' },
    EGYPT: { id: 5, name: 'Egyptian General Authority of Survey' },
    MAKKAH: { id: 4, name: 'Umm al-Qura University, Makkah' },
    KARACHI: { id: 1, name: 'University of Islamic Sciences, Karachi' },
    TEHRAN: { id: 7, name: 'Institute of Geophysics, Tehran University' },
    GULF: { id: 8, name: 'Gulf Region' }
};

// Default settings
let CALCULATION_METHOD = METHODS.MWL;
let ASR_JURISTIC_METHOD = 0; // 0 for Shafi'i, 1 for Hanafi

// Global variable to store the countdown timer
let countdownTimer = null;

// Current position
let currentPosition = {
    latitude: null,
    longitude: null
};

// ======================== API INTEGRATION ======================== //

// Fetch prayer times from API
async function fetchPrayerTimes(latitude, longitude, date) {
    try {
        updateLoadingState(true, 'Fetching prayer times...');
        
        // Format date as YYYY-MM-DD
        const formattedDate = date.toISOString().split('T')[0];
        
        // Create API URL with parameters
        const url = new URL('https://api.aladhan.com/v1/timings');
        url.search = new URLSearchParams({
            latitude: latitude,
            longitude: longitude,
            method: CALCULATION_METHOD.id,
            adjustment: 0,
            tune: "0,0,0,0,0,0,0,0,0",
            school: ASR_JURISTIC_METHOD,
            date: formattedDate
        }).toString();
        
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        updateLoadingState(false);
        
        if (data.code === 200 && data.data && data.data.timings) {
            return formatPrayerTimesFromAPI(data.data.timings);
        } else {
            throw new Error('Invalid data format received from API');
        }
    } catch (error) {
        updateLoadingState(false);
        console.error('Error fetching prayer times:', error);
        
        // Show error to user
        showErrorMessage('Failed to fetch prayer times. Please try again later.');
        
        // Return empty times
        return {
            Fajr: "-----",
            Sunrise: "-----",
            Dhuhr: "-----",
            Asr: "-----",
            Maghrib: "-----",
            Isha: "-----"
        };
    }
}

// Format times from API to match our format
function formatPrayerTimesFromAPI(timings) {
    // Convert API response to our format and convert to 12-hour format
    return {
        Fajr: convertTo12HourFormat(timings.Fajr),
        Sunrise: convertTo12HourFormat(timings.Sunrise),
        Dhuhr: convertTo12HourFormat(timings.Dhuhr),
        Asr: convertTo12HourFormat(timings.Asr),
        Maghrib: convertTo12HourFormat(timings.Maghrib),
        Isha: convertTo12HourFormat(timings.Isha)
    };
}

// Convert time from 24-hour format to 12-hour format
function convertTo12HourFormat(timeStr) {
    if (!timeStr || timeStr === "-----") return "-----";
    
    const [hours24, minutes] = timeStr.split(':').map(Number);
    
    if (isNaN(hours24) || isNaN(minutes)) return "-----";
    
    const period = hours24 >= 12 ? 'PM' : 'AM';
    const hours12 = hours24 % 12 || 12;
    
    return `${hours12.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${period}`;
}

// ======================== FORMATTING FUNCTIONS ======================== //

// Format time string to Arabic numerals
function formatTimeArabic(timeStr) {
    if (timeStr === "-----") return "-----";
    
    // Convert to 24-hour format first
    const [time, period] = timeStr.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    
    // Format with Arabic numerals
    const arabicDigits = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
    const hoursStr = hours.toString().padStart(2, '0').split('').map(d => arabicDigits[parseInt(d)]).join('');
    const minutesStr = minutes.toString().padStart(2, '0').split('').map(d => arabicDigits[parseInt(d)]).join('');
    
    return `${hoursStr}:${minutesStr}`;
}

// Convert time string to Date object for comparison
function convertTimeStringToDate(timeStr) {
    if (timeStr === "-----") return null;
    
    const today = new Date();
    const [time, period] = timeStr.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    
    const result = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hours, minutes);
    return result;
}

// Show error message to user
function showErrorMessage(message) {
    // Check if we have SweetAlert2 available
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            title: 'Error',
            text: message,
            icon: 'error',
            confirmButtonColor: '#6366f1'
        });
    } else {
        alert(message);
    }
}

// ======================== UI UPDATE FUNCTIONS ======================== //

// Safely get DOM element with fallback
function safeGetElement(id, fallback = null) {
    const element = document.getElementById(id);
    if (!element && fallback) {
        console.warn(`Element with ID '${id}' not found, creating it`);
        const newElement = document.createElement(fallback);
        newElement.id = id;
        document.body.appendChild(newElement);
        return newElement;
    }
    return element;
}

// Display the prayer times in the UI
function displayPrayerTimes(times) {
    const container = safeGetElement('prayer-times', 'div');
    if (!container) {
        console.error('Prayer times container not found and could not be created');
        return;
    }
    
    container.innerHTML = '';

    const prayers = {
        Fajr: ['Dawn Prayer', 'fa-sun'],
        Sunrise: ['Sunrise', 'fa-sun'],
        Dhuhr: ['Noon Prayer', 'fa-sun'],
        Asr: ['Afternoon Prayer', 'fa-cloud-sun'],
        Maghrib: ['Sunset Prayer', 'fa-moon'],
        Isha: ['Night Prayer', 'fa-star']
    };

    const currentTime = new Date();
    let nextPrayer = null;
    let nextPrayerTime = null;

    // First determine the next prayer
    Object.entries(prayers).forEach(([prayer, [label, icon]]) => {
        if (times[prayer] === "-----") return;
        
        const prayerDate = convertTimeStringToDate(times[prayer]);
        
        if (prayerDate && prayerDate > currentTime && (!nextPrayerTime || prayerDate < nextPrayerTime)) {
            nextPrayer = prayer;
            nextPrayerTime = prayerDate;
        }
    });

    // Handle case where all prayers have passed for the day
    if (!nextPrayer) {
        // Let the user know that we'll show tomorrow's times for Fajr
        const nextPrayerNameElement = safeGetElement('next-prayer-name', 'div');
        if (nextPrayerNameElement) {
            nextPrayerNameElement.innerHTML = `
                <span class="mr-2">All prayers passed for today. Showing countdown to tomorrow's Fajr</span>
                <span class="arabic mr-2">انتهت جميع الصلوات لهذا اليوم. عرض العد التنازلي لصلاة الفجر غدًا</span>
            `;
        }
        
        // Fetch tomorrow's times for Fajr
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        fetchPrayerTimes(
            currentPosition.latitude, 
            currentPosition.longitude, 
            tomorrow
        ).then(tomorrowTimes => {
            if (tomorrowTimes.Fajr !== "-----") {
                nextPrayer = 'Fajr';
                
                // Create a date for tomorrow's Fajr
                const fajrTime = convertTimeStringToDate(tomorrowTimes.Fajr);
                if (fajrTime) {
                    fajrTime.setDate(fajrTime.getDate() + 1);
                    nextPrayerTime = fajrTime;
                    updateCountdown(nextPrayerTime);
                }
            }
        }).catch(error => {
            console.error("Error fetching tomorrow's prayer times:", error);
            const timeRemainingElement = safeGetElement('time-remaining', 'div');
            if (timeRemainingElement) {
                timeRemainingElement.textContent = "--:--:--";
            }
        });
    }

    // Now create cards
    Object.entries(prayers).forEach(([prayer, [label, icon]], index) => {
        const isActive = prayer === nextPrayer;
        const [primary, secondary] = prayerColors[prayer] || ['#6366f1', '#8b5cf6'];
        
        const card = document.createElement('div');
        card.className = `prayer-time-card rounded-xl shadow-lg p-6 animate__animated animate__fadeIn animate__delay-${index % 5}s ${isActive ? 'active' : ''}`;
        if (isActive) {
            card.style.background = `linear-gradient(145deg, ${primary}15, ${secondary}15)`;
        }
        
        card.innerHTML = `
            <div class="flex items-center justify-between mb-3">
                <div>
                    <h3 class="text-xl font-bold ${isActive ? 'text-indigo-700' : 'text-indigo-600'}">${label}</h3>
                    <p class="text-gray-600">${prayer} | ${prayerNamesArabic[prayer]}</p>
                </div>
                <lord-icon
                    src="${prayerIcons[prayer]}"
                    trigger="hover"
                    colors="primary:${primary},secondary:${secondary}"
                    style="width:48px;height:48px">
                </lord-icon>
            </div>
            <div class="flex items-center justify-between mt-4">
                <div class="flex flex-col">
                    <span class="text-sm text-gray-500">English</span>
                    <span class="text-lg font-semibold ${isActive ? 'text-indigo-700' : 'text-gray-700'}">${times[prayer]}</span>
                </div>
                <div class="flex flex-col items-end">
                    <span class="text-sm text-gray-500">عربي</span>
                    <span dir="rtl" class="text-lg font-semibold arabic ${isActive ? 'text-indigo-700' : 'text-gray-700'}">${formatTimeArabic(times[prayer])}</span>
                </div>
            </div>
            ${isActive ? '<div class="mt-2 text-xs text-indigo-600 font-medium">Next Prayer</div>' : ''}
        `;
        container.appendChild(card);
    });

    // Update next prayer information
    if (nextPrayer && nextPrayerTime) {
        const nextPrayerNameElement = safeGetElement('next-prayer-name', 'div');
        if (nextPrayerNameElement) {
            nextPrayerNameElement.innerHTML = `
                <span class="mr-2">${prayers[nextPrayer][0]} (${nextPrayer})</span>
                <span class="arabic mr-2">${prayerDescArabic[nextPrayer]} (${prayerNamesArabic[nextPrayer]})</span>
            `;
        }
        updateCountdown(nextPrayerTime);
    }
}

// Update the countdown timer
function updateCountdown(targetTime) {
    if (!targetTime) return;
    
    const timeRemainingElement = safeGetElement('time-remaining', 'div');
    if (!timeRemainingElement) {
        console.error('Time remaining element not found and could not be created');
        return;
    }
    
    const updateTimer = () => {
        const now = new Date();
        const diff = targetTime - now;
        
        if (diff <= 0) {
            timeRemainingElement.textContent = "00:00:00";
            // Refresh the page calculations when time is up
            setTimeout(() => {
                refreshPrayerTimes();
            }, 1000);
            return;
        }
        
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        
        timeRemainingElement.textContent = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update every second
        countdownTimer = setTimeout(updateTimer, 1000);
    };
    
    // Clear any existing timer before starting a new one
    if (countdownTimer) {
        clearTimeout(countdownTimer);
    }
    
    updateTimer();
}

// Update the current date
function updateCurrentDate() {
    const currentDateElement = safeGetElement('current-date', 'div');
    if (!currentDateElement) return;
    
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const today = new Date();
    
    const gregorianDate = today.toLocaleDateString('en-US', options);
    currentDateElement.textContent = gregorianDate;
}

// ======================== LOCATION HANDLING ======================== //

// Function to handle location retrieval and updates
async function getCurrentLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            return reject(new Error('Geolocation is not supported by your browser'));
        }
        
        // Show loading state
        updateLoadingState(true, 'Retrieving your location...');
        
        navigator.geolocation.getCurrentPosition(
            // Success callback
            (position) => {
                const { latitude, longitude } = position.coords;
                currentPosition = { latitude, longitude };
                updateLoadingState(false);
                resolve(position.coords);
            },
            // Error callback
            (error) => {
                updateLoadingState(false);
                
                let errorMessage;
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = 'Location access was denied. Prayer times may not be accurate.';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = 'Location information is unavailable. Using default location.';
                        break;
                    case error.TIMEOUT:
                        errorMessage = 'Location request timed out. Using cached or default location.';
                        break;
                    default:
                        errorMessage = 'An unknown error occurred while retrieving location.';
                }
                
                reject(new Error(errorMessage));
            },
            // Options
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
            }
        );
    });
}

// Show/hide a loading indicator
function updateLoadingState(isLoading, message = 'Loading...') {
    const locationDisplay = safeGetElement('location-display', 'div');
    if (!locationDisplay) return;
    
    if (isLoading) {
        locationDisplay.innerHTML = `
            <div class="flex items-center">
                <div class="animate-spin mr-2">
                    <i class="fas fa-circle-notch"></i>
                </div>
                <span>${message}</span>
            </div>
        `;
    } else {
        // Reset to default state - will be updated later
        locationDisplay.innerHTML = `
            <i class="fas fa-map-marker-alt mr-1"></i>
            <span>Location pending...</span>
        `;
    }
}

// Fetch location name from coordinates
async function getLocationName(latitude, longitude) {
    try {
        updateLoadingState(true, 'Finding your city...');
        
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=10`,
            { 
                headers: { 
                    'Accept-Language': 'en',
                    'User-Agent': 'PrayerTimesApp/1.0'
                } 
            }
        );
        
        if (!response.ok) {
            throw new Error('Failed to fetch location data');
        }
        
        const data = await response.json();
        updateLoadingState(false);
        
        return data.address.city || 
               data.address.town || 
               data.address.village || 
               data.address.county ||
               data.address.state ||
               "Unknown Location";
    } catch (error) {
        updateLoadingState(false);
        console.error('Error fetching location name:', error);
        return "Unknown Location";
    }
}

// Update the location display
function updateLocationDisplay(locationName) {
    const locationDisplay = safeGetElement('location-display', 'div');
    if (!locationDisplay) return;
    
    locationDisplay.innerHTML = `
        <i class="fas fa-map-marker-alt mr-1"></i>
        <span>${locationName}</span>
    `;
}

// Handle location error
function handleLocationError(error) {
    console.error('Location error:', error);
    
    // Check if we have Swal (SweetAlert2) available
    if (typeof Swal !== 'undefined') {
        // Show error alert
        Swal.fire({
            title: 'Location Error',
            text: error.message || 'Unable to determine your location. Using default location.',
            icon: 'warning',
            confirmButtonText: 'Use Default Location',
            confirmButtonColor: '#6366f1',
            showCancelButton: true,
            cancelButtonText: 'Try Again',
            cancelButtonColor: '#ef4444'
        }).then((result) => {
            if (result.isConfirmed) {
                // Use default location (Mecca coordinates as fallback)
                currentPosition = { 
                    latitude: 21.4225, 
                    longitude: 39.8262 
                };
                updateLocationDisplay('Mecca (Default)');
                refreshPrayerTimes();
            } else {
                // Try again
                initialize();
            }
        });
    } else {
        // Fallback to simple alert if SweetAlert is not available
        const useDefault = window.confirm(
            `${error.message || 'Unable to determine your location.'} Would you like to use the default location (Mecca)?`
        );
        
        if (useDefault) {
            // Use default location (Mecca coordinates)
            currentPosition = { 
                latitude: 21.4225, 
                longitude: 39.8262 
            };
            updateLocationDisplay('Mecca (Default)');
            refreshPrayerTimes();
        } else {
            // Try again
            initialize();
        }
    }
}

// ======================== APPLICATION INITIALIZATION ======================== //

// Refresh prayer times with current settings
async function refreshPrayerTimes() {
    if (!currentPosition.latitude || !currentPosition.longitude) {
        console.error('No location available');
        return;
    }
    
    try {
        const today = new Date();
        const times = await fetchPrayerTimes(
            currentPosition.latitude, 
            currentPosition.longitude, 
            today
        );
        
        displayPrayerTimes(times);
        updateCurrentDate();
    } catch (error) {
        console.error('Error refreshing prayer times:', error);
        showErrorMessage('Failed to refresh prayer times. Please try again.');
    }
}

// Handle method selection change
function handleMethodChange(methodName) {
    if (METHODS[methodName]) {
        CALCULATION_METHOD = METHODS[methodName];
        
        // Update method display
        const methodDisplay = safeGetElement('calculation-method', 'div');
        if (methodDisplay) {
            methodDisplay.textContent = CALCULATION_METHOD.name;
        }
        
        // Save the setting
        localStorage.setItem('prayerCalculationMethod', methodName);
        
        refreshPrayerTimes();
    }
}

// Handle Asr calculation method change
function handleAsrMethodChange(asrMethod) {
    ASR_JURISTIC_METHOD = parseInt(asrMethod) || 0;
    
    // Update Asr method display
    const asrMethodDisplay = safeGetElement('asr-method', 'div');
    if (asrMethodDisplay) {
        asrMethodDisplay.textContent = ASR_JURISTIC_METHOD === 0 ? 'Shafi\'i' : 'Hanafi';
    }
    
    // Save the setting
    localStorage.setItem('asrJuristicMethod', ASR_JURISTIC_METHOD.toString());
    
    refreshPrayerTimes();
}

// Setup event listeners for controls
function setupEventListeners() {
    // Method selection
    const methodSelect = safeGetElement('method-select', 'select');
    if (methodSelect) {
        // Populate method options if not already done
        if (methodSelect.options.length === 0) {
            Object.keys(METHODS).forEach(method => {
                const option = document.createElement('option');
                option.value = method;
                option.textContent = METHODS[method].name;
                methodSelect.appendChild(option);
            });
        }
        
        methodSelect.value = Object.keys(METHODS).find(
            key => METHODS[key].name === CALCULATION_METHOD.name
        ) || 'MWL';
        
        methodSelect.addEventListener('change', (e) => {
            handleMethodChange(e.target.value);
        });
    }
    
    // Asr method selection
    const asrMethodSelect = safeGetElement('asr-method-select', 'select');
    if (asrMethodSelect) {
        // Populate Asr method options if not already done
        if (asrMethodSelect.options.length === 0) {
            const options = [
                { value: '0', text: 'Shafi\'i (Standard)' },
                { value: '1', text: 'Hanafi' }
            ];
            
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.text;
                asrMethodSelect.appendChild(option);
            });
        }
        
        asrMethodSelect.value = ASR_JURISTIC_METHOD.toString();
        
        asrMethodSelect.addEventListener('change', (e) => {
            handleAsrMethodChange(e.target.value);
        });
    }
    
    // Refresh button
    const refreshButton = safeGetElement('refresh-button', 'button');
    if (refreshButton) {
        refreshButton.addEventListener('click', () => {
            initialize();
        });
    }
}

// Load settings from localStorage if available
function loadSettings() {
    try {
        // Load calculation method
        const savedMethod = localStorage.getItem('prayerCalculationMethod');
        if (savedMethod && METHODS[savedMethod]) {
            CALCULATION_METHOD = METHODS[savedMethod];
        }
        
        // Load Asr calculation method
        const savedAsrMethod = localStorage.getItem('asrJuristicMethod');
        if (savedAsrMethod !== null) {
            ASR_JURISTIC_METHOD = parseInt(savedAsrMethod) || 0;
        }
        
        // Update UI to reflect loaded settings
        const methodDisplay = safeGetElement('calculation-method', 'div');
        if (methodDisplay) {
            methodDisplay.textContent = CALCULATION_METHOD.name;
        }
        
        const asrMethodDisplay = safeGetElement('asr-method', 'div');
        if (asrMethodDisplay) {
            asrMethodDisplay.textContent = ASR_JURISTIC_METHOD === 0 ? 'Shafi\'i' : 'Hanafi';
        }
    } catch (error) {
        console.error('Error loading settings:', error);
    }
}

// Initialize the application
async function initialize() {
    // Load saved settings
    loadSettings();
    
    // Setup UI event listeners
    setupEventListeners();
    
    try {
        // Get user location
        const coords = await getCurrentLocation();
        
        // Get location name
        const locationName = await getLocationName(coords.latitude, coords.longitude);
        updateLocationDisplay(locationName);
        
        // Calculate and display prayer times
        await refreshPrayerTimes();
    } catch (error) {
        handleLocationError(error);
    }
}

// Run initialization when DOM is loaded
document.addEventListener('DOMContentLoaded', initialize);

// Set up auto-refresh every minute to keep countdown accurate
setInterval(() => {
    const now = new Date();
    if (now.getSeconds() === 0) {
        refreshPrayerTimes();
    }
}, 1000);

// ======================== THEME AND LANGUAGE FUNCTIONS ======================== //

// Toggle dark mode
function toggleDarkMode() {
    const body = document.body;
    body.classList.toggle('dark-mode');
    
    // Save preference
    const isDarkMode = body.classList.contains('dark-mode');
    localStorage.setItem('darkMode', isDarkMode ? 'true' : 'false');
    
    // Update button icon
    const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
    if (darkModeButton) {
        darkModeButton.innerHTML = isDarkMode ? 
            '<i class="fas fa-sun"></i>' : 
            '<i class="fas fa-moon"></i>';
    }
}

// Toggle Arabic/English display priority
function toggleLanguage() {
    const container = document.getElementById('app-container');
    container.classList.toggle('arabic-primary');
    
    // Save preference
    const isArabicPrimary = container.classList.contains('arabic-primary');
    localStorage.setItem('arabicPrimary', isArabicPrimary ? 'true' : 'false');
    
    // Update button text
    const langButton = safeGetElement('language-toggle', 'button');
    if (langButton) {
        langButton.textContent = isArabicPrimary ? 'English' : 'العربية';
    }
}

// Load theme and language preferences
function loadPreferences() {
    // Dark mode preference
    const darkModeSetting = localStorage.getItem('darkMode');
    if (darkModeSetting === 'true') {
        document.body.classList.add('dark-mode');
        
        const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
        if (darkModeButton) {
            darkModeButton.innerHTML = '<i class="fas fa-sun"></i>';
        }
    }
    
    // Language preference
    const arabicPrimarySetting = localStorage.getItem('arabicPrimary');
    if (arabicPrimarySetting === 'true') {
        const container = document.getElementById('app-container');
        if (container) {
            container.classList.add('arabic-primary');
        }
        
        const langButton = safeGetElement('language-toggle', 'button');
        if (langButton) {
            langButton.textContent = 'English';
        }
    }
}

// Setup theme and language toggles
function setupPreferenceControls() {
    // Dark mode toggle
    const darkModeButton = safeGetElement('dark-mode-toggle', 'button');
    if (darkModeButton) {
        darkModeButton.addEventListener('click', toggleDarkMode);
    }
    
    // Language toggle
    const langButton = safeGetElement('language-toggle', 'button');
    if (langButton) {
        langButton.addEventListener('click', toggleLanguage);
    }
}

// Add preference controls setup to initialization
document.addEventListener('DOMContentLoaded', () => {
    // Setup preference controls
    setupPreferenceControls();
    
    // Load saved preferences
    loadPreferences();
    
    // Initialize the app
    initialize();
});

// ======================== RESPONSIVE LAYOUT ADJUSTMENTS ======================== //

// Adjust layout based on screen size
function handleResponsiveLayout() {
    const prayerContainer = document.getElementById('prayer-times');
    if (!prayerContainer) return;
    
    // Adjust grid columns based on screen width
    if (window.innerWidth < 640) {
        prayerContainer.className = 'grid grid-cols-1 gap-4 mt-6';
    } else if (window.innerWidth < 1024) {
        prayerContainer.className = 'grid grid-cols-2 gap-4 mt-6';
    } else {
        prayerContainer.className = 'grid grid-cols-3 gap-4 mt-6';
    }
}

// Listen for window resize
window.addEventListener('resize', handleResponsiveLayout);

// Call once on load
document.addEventListener('DOMContentLoaded', handleResponsiveLayout);

// ======================== EXPORT & SHARE FUNCTIONS ======================== //

// Export prayer times to calendar
function exportToCalendar() {
    if (!currentPosition.latitude || !currentPosition.longitude) {
        showErrorMessage('No location data available for export.');
        return;
    }
    
    try {
        // Show loading state
        updateLoadingState(true, 'Generating calendar events...');
        
        // We'll fetch a month of prayer times
        const today = new Date();
        const endDate = new Date();
        endDate.setDate(today.getDate() + 30);
        
        let currentDate = new Date(today);
        
        // Create a queue of dates to process
        const dates = [];
        while (currentDate <= endDate) {
            dates.push(new Date(currentDate));
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Process the queue sequentially to avoid API rate limits
        processDateQueue(dates, 0)
            .then(events => {
                updateLoadingState(false);
                
                // Generate ICS file content
                const icsContent = generateICSFile(events);
                
                // Create and trigger download
                const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'prayer_times.ics';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success message
                if (typeof Swal !== 'undefined') {
                    Swal.fire({
                        title: 'Success!',
                        text: 'Prayer times have been exported to your calendar.',
                        icon: 'success',
                        confirmButtonColor: '#6366f1'
                    });
                } else {
                    alert('Prayer times have been exported to your calendar.');
                }
            })
            .catch(error => {
                updateLoadingState(false);
                console.error('Error exporting to calendar:', error);
                showErrorMessage('Failed to export prayer times. Please try again later.');
            });
    } catch (error) {
        updateLoadingState(false);
        console.error('Error in export function:', error);
        showErrorMessage('An unexpected error occurred during export.');
    }
}

// Process a queue of dates to fetch prayer times
async function processDateQueue(dates, index) {
    if (index >= dates.length) return [];
    
    try {
        // Update loading message with progress
        updateLoadingState(true, `Generating calendar events (${index + 1}/${dates.length})...`);
        
        // Fetch prayer times for this date
        const times = await fetchPrayerTimes(
            currentPosition.latitude,
            currentPosition.longitude,
            dates[index]
        );
        
        // Create events for this date
        const events = createEventsForDate(dates[index], times);
        
        // Process the next date (with a small delay to respect API rate limits)
        return new Promise(resolve => {
            setTimeout(async () => {
                const remainingEvents = await processDateQueue(dates, index + 1);
                resolve([...events, ...remainingEvents]);
            }, 250); // 250ms delay between requests
        });
    } catch (error) {
        console.error(`Error processing date ${dates[index].toISOString()}:`, error);
        // Continue with the next date even if this one failed
        return processDateQueue(dates, index + 1);
    }
}

// Create calendar events for a specific date
function createEventsForDate(date, times) {
    const events = [];
    
    // Prayers to include (excluding Sunrise)
    const prayers = ['Fajr', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];
    
    prayers.forEach(prayer => {
        if (times[prayer] === "-----") return;
        
        // Convert time string to Date object
        const timeDate = convertTimeStringToDate(times[prayer]);
        if (!timeDate) return;
        
        // Set the correct date (keeping the time)
        timeDate.setFullYear(date.getFullYear());
        timeDate.setMonth(date.getMonth());
        timeDate.setDate(date.getDate());
        
        // Create event (30 minutes duration for prayers)
        const endTime = new Date(timeDate);
        endTime.setMinutes(endTime.getMinutes() + 30);
        
        events.push({
            title: `${prayer} Prayer`,
            start: timeDate,
            end: endTime,
            description: `${prayer} Prayer (${prayerNamesArabic[prayer]})`
        });
    });
    
    return events;
}

// Generate ICS file content
function generateICSFile(events) {
    // Start ICS file
    let icsContent = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Prayer Times App//EN',
        'CALSCALE:GREGORIAN',
        'METHOD:PUBLISH'
    ].join('\r\n') + '\r\n';
    
    // Add each event
    events.forEach(event => {
        // Format dates in ICS format
        const startDate = formatDateForICS(event.start);
        const endDate = formatDateForICS(event.end);
        
        // Create unique ID for event
        const eventId = 'prayer-' + Math.random().toString(36).substring(2, 15);
        
        // Add event to ICS content
        icsContent += [
            'BEGIN:VEVENT',
            `UID:${eventId}`,
            `DTSTAMP:${formatDateForICS(new Date())}`,
            `DTSTART:${startDate}`,
            `DTEND:${endDate}`,
            `SUMMARY:${event.title}`,
            `DESCRIPTION:${event.description}`,
            'END:VEVENT'
        ].join('\r\n') + '\r\n';
    });
    
    // End ICS file
    icsContent += 'END:VCALENDAR';
    
    return icsContent;
}

// Format date for ICS file
function formatDateForICS(date) {
    return date.getUTCFullYear() +
           String(date.getUTCMonth() + 1).padStart(2, '0') +
           String(date.getUTCDate()).padStart(2, '0') + 'T' +
           String(date.getUTCHours()).padStart(2, '0') +
           String(date.getUTCMinutes()).padStart(2, '0') +
           String(date.getUTCSeconds()).padStart(2, '0') + 'Z';
}

// Share current prayer times
function sharePrayerTimes() {
    // Check if sharing is supported
    if (!navigator.share) {
        // Fallback for browsers that don't support Web Share API
        copyPrayerTimesToClipboard();
        return;
    }
    
    // Get prayer times container
    const prayerContainer = document.getElementById('prayer-times');
    if (!prayerContainer) {
        showErrorMessage('No prayer times available to share.');
        return;
    }
    
    // Prepare text to share
    const today = new Date().toLocaleDateString();
    const locationDisplay = document.getElementById('location-display');
    const location = locationDisplay ? locationDisplay.textContent.trim() : 'Current Location';
    
    let shareText = `Prayer Times for ${today} (${location})\n\n`;
    
    // Extract prayer times from the DOM
    const prayers = ['Fajr', 'Sunrise', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];
    prayers.forEach(prayer => {
        const card = prayerContainer.querySelector(`.prayer-time-card:nth-child(${prayers.indexOf(prayer) + 1})`);
        if (!card) return;
        
        const timeElement = card.querySelector('.text-lg.font-semibold:not(.arabic)');
        if (!timeElement) return;
        
        shareText += `${prayer}: ${timeElement.textContent.trim()}\n`;
    });
    
    // Add app attribution
    shareText += `\nShared from Prayer Times App`;
    
    // Share the text
    navigator.share({
        title: 'Prayer Times',
        text: shareText
    })
    .catch(error => {
        console.error('Error sharing:', error);
        
        // Fall back to clipboard copy if sharing fails
        copyPrayerTimesToClipboard(shareText);
    });
}

// Copy prayer times to clipboard
function copyPrayerTimesToClipboard(shareText) {
    // If shareText was not provided, generate it
    if (!shareText) {
        const today = new Date().toLocaleDateString();
        const locationDisplay = document.getElementById('location-display');
        const location = locationDisplay ? locationDisplay.textContent.trim() : 'Current Location';
        
        shareText = `Prayer Times for ${today} (${location})\n\n`;
        
        // Extract prayer times from the DOM
        const prayers = ['Fajr', 'Sunrise', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];
        const prayerContainer = document.getElementById('prayer-times');
        
        if (prayerContainer) {
            prayers.forEach(prayer => {
                const card = prayerContainer.querySelector(`.prayer-time-card:nth-child(${prayers.indexOf(prayer) + 1})`);
                if (!card) return;
                
                const timeElement = card.querySelector('.text-lg.font-semibold:not(.arabic)');
                if (!timeElement) return;
                
                shareText += `${prayer}: ${timeElement.textContent.trim()}\n`;
            });
        }
        
        // Add app attribution
        shareText += `\nShared from Prayer Times App`;
    }
    
    // Copy to clipboard
    navigator.clipboard.writeText(shareText)
        .then(() => {
            // Show success message
            if (typeof Swal !== 'undefined') {
                Swal.fire({
                    title: 'Copied!',
                    text: 'Prayer times have been copied to clipboard.',
                    icon: 'success',
                    confirmButtonColor: '#6366f1',
                    timer: 1500
                });
            } else {
                alert('Prayer times have been copied to clipboard.');
            }
        })
        .catch(error => {
            console.error('Error copying to clipboard:', error);
            showErrorMessage('Failed to copy prayer times to clipboard.');
        });
}

// Setup share buttons
function setupShareButtons() {
    // Export to calendar button
    const exportButton = safeGetElement('export-button', 'button');
    if (exportButton) {
        exportButton.addEventListener('click', exportToCalendar);
    }
    
    // Share button
    const shareButton = safeGetElement('share-button', 'button');
    if (shareButton) {
        shareButton.addEventListener('click', sharePrayerTimes);
    }
}

// Add share buttons setup to initialization
document.addEventListener('DOMContentLoaded', setupShareButtons);
    </script>
</body>
</html>
